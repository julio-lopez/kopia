package stats

import (
	"sync"
	"sync/atomic"
)

// CountersMap is a concurrency-safe map from keys of type K to uint32 counters.
// It allows increments and retrievals of counts from concurrent go routines
// without additional concurrency coordination.
type CountersMap[K comparable] struct {
	// Stores map[K]*uint32
	// The counter is stored as pointer so it can be updated with atomic operations.
	data sync.Map
}

// Increment increases the counter for the specified key by 1.
// Returns true if the key already existed, false if it was newly created.
func (m *CountersMap[K]) Increment(key K) bool {
	return m.Add(key, 1)
}

// Add increases the counter for the specified key by the value of v.
// Returns true if the key already existed, false if it was newly created.
func (m *CountersMap[K]) Add(key K, v uint32) bool {
	// Attempt looking for an already existing entry first to avoid spurious
	// (value) allocations in workloads where the entry likely exists already.
	actual, found := m.data.Load(key)
	if !found {
		actual, found = m.data.LoadOrStore(key, new(uint32))
	}

	atomic.AddUint32(actual.(*uint32), v) //nolint:forcetypeassert

	return found
}

// Get returns the current value of the counter for key, or 0 when key does not exist.
func (m *CountersMap[K]) Get(key K) (uint32, bool) {
	actual, ok := m.data.Load(key)
	if !ok {
		return 0, false // Key not found, return 0
	}

	return atomic.LoadUint32(actual.(*uint32)), true //nolint:forcetypeassert
}

// Range iterates over all key/count pairs in the map, calling f for each item.
// If f returns false, iteration stops.
func (m *CountersMap[K]) Range(f func(key K, count uint32) bool) {
	m.data.Range(func(k any, v any) bool {
		return f(k.(K), atomic.LoadUint32(v.(*uint32))) //nolint:forcetypeassert
	})
}

// CountMap returns the current value of the counters. The counters do not
// correspond to a consistent snapshot of the map, the counters may change
// while the returned map is built.
func (m *CountersMap[K]) CountMap() map[K]uint32 {
	r := map[K]uint32{}

	m.Range(func(key K, count uint32) bool {
		r[key] = count

		return true
	})

	return r
}
